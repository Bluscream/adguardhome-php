<?php
/**
 * DNSConfig
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AdGuard Home
 *
 * AdGuard Home REST-ish API.  Our admin web interface is built on top of this REST-ish API.
 *
 * OpenAPI spec version: 0.107
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.34
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * DNSConfig Class Doc Comment
 *
 * @category Class
 * @description Query log configuration
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class DNSConfig implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'DNSConfig';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'bootstrap_dns' => 'string[]',
'upstream_dns' => 'string[]',
'upstream_dns_file' => 'string',
'protection_enabled' => 'bool',
'dhcp_available' => 'bool',
'ratelimit' => 'int',
'blocking_mode' => 'string',
'blocking_ipv4' => 'string',
'blocking_ipv6' => 'string',
'edns_cs_enabled' => 'bool',
'disable_ipv6' => 'bool',
'dnssec_enabled' => 'bool',
'cache_size' => 'int',
'cache_ttl_min' => 'int',
'cache_ttl_max' => 'int',
'cache_optimistic' => 'bool',
'upstream_mode' => 'string',
'use_private_ptr_resolvers' => 'bool',
'resolve_clients' => 'bool',
'local_ptr_upstreams' => 'string[]'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'bootstrap_dns' => null,
'upstream_dns' => null,
'upstream_dns_file' => null,
'protection_enabled' => null,
'dhcp_available' => null,
'ratelimit' => null,
'blocking_mode' => null,
'blocking_ipv4' => null,
'blocking_ipv6' => null,
'edns_cs_enabled' => null,
'disable_ipv6' => null,
'dnssec_enabled' => null,
'cache_size' => null,
'cache_ttl_min' => null,
'cache_ttl_max' => null,
'cache_optimistic' => null,
'upstream_mode' => null,
'use_private_ptr_resolvers' => null,
'resolve_clients' => null,
'local_ptr_upstreams' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'bootstrap_dns' => 'bootstrap_dns',
'upstream_dns' => 'upstream_dns',
'upstream_dns_file' => 'upstream_dns_file',
'protection_enabled' => 'protection_enabled',
'dhcp_available' => 'dhcp_available',
'ratelimit' => 'ratelimit',
'blocking_mode' => 'blocking_mode',
'blocking_ipv4' => 'blocking_ipv4',
'blocking_ipv6' => 'blocking_ipv6',
'edns_cs_enabled' => 'edns_cs_enabled',
'disable_ipv6' => 'disable_ipv6',
'dnssec_enabled' => 'dnssec_enabled',
'cache_size' => 'cache_size',
'cache_ttl_min' => 'cache_ttl_min',
'cache_ttl_max' => 'cache_ttl_max',
'cache_optimistic' => 'cache_optimistic',
'upstream_mode' => 'upstream_mode',
'use_private_ptr_resolvers' => 'use_private_ptr_resolvers',
'resolve_clients' => 'resolve_clients',
'local_ptr_upstreams' => 'local_ptr_upstreams'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'bootstrap_dns' => 'setBootstrapDns',
'upstream_dns' => 'setUpstreamDns',
'upstream_dns_file' => 'setUpstreamDnsFile',
'protection_enabled' => 'setProtectionEnabled',
'dhcp_available' => 'setDhcpAvailable',
'ratelimit' => 'setRatelimit',
'blocking_mode' => 'setBlockingMode',
'blocking_ipv4' => 'setBlockingIpv4',
'blocking_ipv6' => 'setBlockingIpv6',
'edns_cs_enabled' => 'setEdnsCsEnabled',
'disable_ipv6' => 'setDisableIpv6',
'dnssec_enabled' => 'setDnssecEnabled',
'cache_size' => 'setCacheSize',
'cache_ttl_min' => 'setCacheTtlMin',
'cache_ttl_max' => 'setCacheTtlMax',
'cache_optimistic' => 'setCacheOptimistic',
'upstream_mode' => 'setUpstreamMode',
'use_private_ptr_resolvers' => 'setUsePrivatePtrResolvers',
'resolve_clients' => 'setResolveClients',
'local_ptr_upstreams' => 'setLocalPtrUpstreams'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'bootstrap_dns' => 'getBootstrapDns',
'upstream_dns' => 'getUpstreamDns',
'upstream_dns_file' => 'getUpstreamDnsFile',
'protection_enabled' => 'getProtectionEnabled',
'dhcp_available' => 'getDhcpAvailable',
'ratelimit' => 'getRatelimit',
'blocking_mode' => 'getBlockingMode',
'blocking_ipv4' => 'getBlockingIpv4',
'blocking_ipv6' => 'getBlockingIpv6',
'edns_cs_enabled' => 'getEdnsCsEnabled',
'disable_ipv6' => 'getDisableIpv6',
'dnssec_enabled' => 'getDnssecEnabled',
'cache_size' => 'getCacheSize',
'cache_ttl_min' => 'getCacheTtlMin',
'cache_ttl_max' => 'getCacheTtlMax',
'cache_optimistic' => 'getCacheOptimistic',
'upstream_mode' => 'getUpstreamMode',
'use_private_ptr_resolvers' => 'getUsePrivatePtrResolvers',
'resolve_clients' => 'getResolveClients',
'local_ptr_upstreams' => 'getLocalPtrUpstreams'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const BLOCKING_MODE__DEFAULT = 'default';
const BLOCKING_MODE_REFUSED = 'refused';
const BLOCKING_MODE_NXDOMAIN = 'nxdomain';
const BLOCKING_MODE_NULL_IP = 'null_ip';
const BLOCKING_MODE_CUSTOM_IP = 'custom_ip';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getBlockingModeAllowableValues()
    {
        return [
            self::BLOCKING_MODE__DEFAULT,
self::BLOCKING_MODE_REFUSED,
self::BLOCKING_MODE_NXDOMAIN,
self::BLOCKING_MODE_NULL_IP,
self::BLOCKING_MODE_CUSTOM_IP,        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['bootstrap_dns'] = isset($data['bootstrap_dns']) ? $data['bootstrap_dns'] : null;
        $this->container['upstream_dns'] = isset($data['upstream_dns']) ? $data['upstream_dns'] : null;
        $this->container['upstream_dns_file'] = isset($data['upstream_dns_file']) ? $data['upstream_dns_file'] : null;
        $this->container['protection_enabled'] = isset($data['protection_enabled']) ? $data['protection_enabled'] : null;
        $this->container['dhcp_available'] = isset($data['dhcp_available']) ? $data['dhcp_available'] : null;
        $this->container['ratelimit'] = isset($data['ratelimit']) ? $data['ratelimit'] : null;
        $this->container['blocking_mode'] = isset($data['blocking_mode']) ? $data['blocking_mode'] : null;
        $this->container['blocking_ipv4'] = isset($data['blocking_ipv4']) ? $data['blocking_ipv4'] : null;
        $this->container['blocking_ipv6'] = isset($data['blocking_ipv6']) ? $data['blocking_ipv6'] : null;
        $this->container['edns_cs_enabled'] = isset($data['edns_cs_enabled']) ? $data['edns_cs_enabled'] : null;
        $this->container['disable_ipv6'] = isset($data['disable_ipv6']) ? $data['disable_ipv6'] : null;
        $this->container['dnssec_enabled'] = isset($data['dnssec_enabled']) ? $data['dnssec_enabled'] : null;
        $this->container['cache_size'] = isset($data['cache_size']) ? $data['cache_size'] : null;
        $this->container['cache_ttl_min'] = isset($data['cache_ttl_min']) ? $data['cache_ttl_min'] : null;
        $this->container['cache_ttl_max'] = isset($data['cache_ttl_max']) ? $data['cache_ttl_max'] : null;
        $this->container['cache_optimistic'] = isset($data['cache_optimistic']) ? $data['cache_optimistic'] : null;
        $this->container['upstream_mode'] = isset($data['upstream_mode']) ? $data['upstream_mode'] : null;
        $this->container['use_private_ptr_resolvers'] = isset($data['use_private_ptr_resolvers']) ? $data['use_private_ptr_resolvers'] : null;
        $this->container['resolve_clients'] = isset($data['resolve_clients']) ? $data['resolve_clients'] : null;
        $this->container['local_ptr_upstreams'] = isset($data['local_ptr_upstreams']) ? $data['local_ptr_upstreams'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getBlockingModeAllowableValues();
        if (!is_null($this->container['blocking_mode']) && !in_array($this->container['blocking_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'blocking_mode', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets bootstrap_dns
     *
     * @return string[]
     */
    public function getBootstrapDns()
    {
        return $this->container['bootstrap_dns'];
    }

    /**
     * Sets bootstrap_dns
     *
     * @param string[] $bootstrap_dns Bootstrap servers, port is optional after colon.  Empty value will reset it to default values.
     *
     * @return $this
     */
    public function setBootstrapDns($bootstrap_dns)
    {
        $this->container['bootstrap_dns'] = $bootstrap_dns;

        return $this;
    }

    /**
     * Gets upstream_dns
     *
     * @return string[]
     */
    public function getUpstreamDns()
    {
        return $this->container['upstream_dns'];
    }

    /**
     * Sets upstream_dns
     *
     * @param string[] $upstream_dns Upstream servers, port is optional after colon.  Empty value will reset it to default values.
     *
     * @return $this
     */
    public function setUpstreamDns($upstream_dns)
    {
        $this->container['upstream_dns'] = $upstream_dns;

        return $this;
    }

    /**
     * Gets upstream_dns_file
     *
     * @return string
     */
    public function getUpstreamDnsFile()
    {
        return $this->container['upstream_dns_file'];
    }

    /**
     * Sets upstream_dns_file
     *
     * @param string $upstream_dns_file upstream_dns_file
     *
     * @return $this
     */
    public function setUpstreamDnsFile($upstream_dns_file)
    {
        $this->container['upstream_dns_file'] = $upstream_dns_file;

        return $this;
    }

    /**
     * Gets protection_enabled
     *
     * @return bool
     */
    public function getProtectionEnabled()
    {
        return $this->container['protection_enabled'];
    }

    /**
     * Sets protection_enabled
     *
     * @param bool $protection_enabled protection_enabled
     *
     * @return $this
     */
    public function setProtectionEnabled($protection_enabled)
    {
        $this->container['protection_enabled'] = $protection_enabled;

        return $this;
    }

    /**
     * Gets dhcp_available
     *
     * @return bool
     */
    public function getDhcpAvailable()
    {
        return $this->container['dhcp_available'];
    }

    /**
     * Sets dhcp_available
     *
     * @param bool $dhcp_available dhcp_available
     *
     * @return $this
     */
    public function setDhcpAvailable($dhcp_available)
    {
        $this->container['dhcp_available'] = $dhcp_available;

        return $this;
    }

    /**
     * Gets ratelimit
     *
     * @return int
     */
    public function getRatelimit()
    {
        return $this->container['ratelimit'];
    }

    /**
     * Sets ratelimit
     *
     * @param int $ratelimit ratelimit
     *
     * @return $this
     */
    public function setRatelimit($ratelimit)
    {
        $this->container['ratelimit'] = $ratelimit;

        return $this;
    }

    /**
     * Gets blocking_mode
     *
     * @return string
     */
    public function getBlockingMode()
    {
        return $this->container['blocking_mode'];
    }

    /**
     * Sets blocking_mode
     *
     * @param string $blocking_mode blocking_mode
     *
     * @return $this
     */
    public function setBlockingMode($blocking_mode)
    {
        $allowedValues = $this->getBlockingModeAllowableValues();
        if (!is_null($blocking_mode) && !in_array($blocking_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'blocking_mode', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['blocking_mode'] = $blocking_mode;

        return $this;
    }

    /**
     * Gets blocking_ipv4
     *
     * @return string
     */
    public function getBlockingIpv4()
    {
        return $this->container['blocking_ipv4'];
    }

    /**
     * Sets blocking_ipv4
     *
     * @param string $blocking_ipv4 blocking_ipv4
     *
     * @return $this
     */
    public function setBlockingIpv4($blocking_ipv4)
    {
        $this->container['blocking_ipv4'] = $blocking_ipv4;

        return $this;
    }

    /**
     * Gets blocking_ipv6
     *
     * @return string
     */
    public function getBlockingIpv6()
    {
        return $this->container['blocking_ipv6'];
    }

    /**
     * Sets blocking_ipv6
     *
     * @param string $blocking_ipv6 blocking_ipv6
     *
     * @return $this
     */
    public function setBlockingIpv6($blocking_ipv6)
    {
        $this->container['blocking_ipv6'] = $blocking_ipv6;

        return $this;
    }

    /**
     * Gets edns_cs_enabled
     *
     * @return bool
     */
    public function getEdnsCsEnabled()
    {
        return $this->container['edns_cs_enabled'];
    }

    /**
     * Sets edns_cs_enabled
     *
     * @param bool $edns_cs_enabled edns_cs_enabled
     *
     * @return $this
     */
    public function setEdnsCsEnabled($edns_cs_enabled)
    {
        $this->container['edns_cs_enabled'] = $edns_cs_enabled;

        return $this;
    }

    /**
     * Gets disable_ipv6
     *
     * @return bool
     */
    public function getDisableIpv6()
    {
        return $this->container['disable_ipv6'];
    }

    /**
     * Sets disable_ipv6
     *
     * @param bool $disable_ipv6 disable_ipv6
     *
     * @return $this
     */
    public function setDisableIpv6($disable_ipv6)
    {
        $this->container['disable_ipv6'] = $disable_ipv6;

        return $this;
    }

    /**
     * Gets dnssec_enabled
     *
     * @return bool
     */
    public function getDnssecEnabled()
    {
        return $this->container['dnssec_enabled'];
    }

    /**
     * Sets dnssec_enabled
     *
     * @param bool $dnssec_enabled dnssec_enabled
     *
     * @return $this
     */
    public function setDnssecEnabled($dnssec_enabled)
    {
        $this->container['dnssec_enabled'] = $dnssec_enabled;

        return $this;
    }

    /**
     * Gets cache_size
     *
     * @return int
     */
    public function getCacheSize()
    {
        return $this->container['cache_size'];
    }

    /**
     * Sets cache_size
     *
     * @param int $cache_size cache_size
     *
     * @return $this
     */
    public function setCacheSize($cache_size)
    {
        $this->container['cache_size'] = $cache_size;

        return $this;
    }

    /**
     * Gets cache_ttl_min
     *
     * @return int
     */
    public function getCacheTtlMin()
    {
        return $this->container['cache_ttl_min'];
    }

    /**
     * Sets cache_ttl_min
     *
     * @param int $cache_ttl_min cache_ttl_min
     *
     * @return $this
     */
    public function setCacheTtlMin($cache_ttl_min)
    {
        $this->container['cache_ttl_min'] = $cache_ttl_min;

        return $this;
    }

    /**
     * Gets cache_ttl_max
     *
     * @return int
     */
    public function getCacheTtlMax()
    {
        return $this->container['cache_ttl_max'];
    }

    /**
     * Sets cache_ttl_max
     *
     * @param int $cache_ttl_max cache_ttl_max
     *
     * @return $this
     */
    public function setCacheTtlMax($cache_ttl_max)
    {
        $this->container['cache_ttl_max'] = $cache_ttl_max;

        return $this;
    }

    /**
     * Gets cache_optimistic
     *
     * @return bool
     */
    public function getCacheOptimistic()
    {
        return $this->container['cache_optimistic'];
    }

    /**
     * Sets cache_optimistic
     *
     * @param bool $cache_optimistic cache_optimistic
     *
     * @return $this
     */
    public function setCacheOptimistic($cache_optimistic)
    {
        $this->container['cache_optimistic'] = $cache_optimistic;

        return $this;
    }

    /**
     * Gets upstream_mode
     *
     * @return string
     */
    public function getUpstreamMode()
    {
        return $this->container['upstream_mode'];
    }

    /**
     * Sets upstream_mode
     *
     * @param string $upstream_mode upstream_mode
     *
     * @return $this
     */
    public function setUpstreamMode($upstream_mode)
    {
        $this->container['upstream_mode'] = $upstream_mode;

        return $this;
    }

    /**
     * Gets use_private_ptr_resolvers
     *
     * @return bool
     */
    public function getUsePrivatePtrResolvers()
    {
        return $this->container['use_private_ptr_resolvers'];
    }

    /**
     * Sets use_private_ptr_resolvers
     *
     * @param bool $use_private_ptr_resolvers use_private_ptr_resolvers
     *
     * @return $this
     */
    public function setUsePrivatePtrResolvers($use_private_ptr_resolvers)
    {
        $this->container['use_private_ptr_resolvers'] = $use_private_ptr_resolvers;

        return $this;
    }

    /**
     * Gets resolve_clients
     *
     * @return bool
     */
    public function getResolveClients()
    {
        return $this->container['resolve_clients'];
    }

    /**
     * Sets resolve_clients
     *
     * @param bool $resolve_clients resolve_clients
     *
     * @return $this
     */
    public function setResolveClients($resolve_clients)
    {
        $this->container['resolve_clients'] = $resolve_clients;

        return $this;
    }

    /**
     * Gets local_ptr_upstreams
     *
     * @return string[]
     */
    public function getLocalPtrUpstreams()
    {
        return $this->container['local_ptr_upstreams'];
    }

    /**
     * Sets local_ptr_upstreams
     *
     * @param string[] $local_ptr_upstreams Upstream servers, port is optional after colon.  Empty value will reset it to default values.
     *
     * @return $this
     */
    public function setLocalPtrUpstreams($local_ptr_upstreams)
    {
        $this->container['local_ptr_upstreams'] = $local_ptr_upstreams;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
