<?php
/**
 * TlsConfig
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AdGuard Home
 *
 * AdGuard Home REST-ish API.  Our admin web interface is built on top of this REST-ish API.
 *
 * OpenAPI spec version: 0.107
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.34
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * TlsConfig Class Doc Comment
 *
 * @category Class
 * @description TLS configuration settings and status
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class TlsConfig implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'TlsConfig';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'enabled' => 'bool',
'server_name' => 'string',
'force_https' => 'bool',
'port_https' => 'int',
'port_dns_over_tls' => 'int',
'port_dns_over_quic' => 'int',
'certificate_chain' => 'string',
'private_key' => 'string',
'private_key_saved' => 'bool',
'certificate_path' => 'string',
'private_key_path' => 'string',
'valid_cert' => 'bool',
'valid_chain' => 'bool',
'subject' => 'string',
'issuer' => 'string',
'not_before' => 'string',
'not_after' => 'string',
'dns_names' => 'string[]',
'valid_key' => 'bool',
'key_type' => 'string',
'warning_validation' => 'string',
'valid_pair' => 'bool'    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'enabled' => null,
'server_name' => null,
'force_https' => null,
'port_https' => 'uint16',
'port_dns_over_tls' => 'uint16',
'port_dns_over_quic' => 'uint16',
'certificate_chain' => null,
'private_key' => null,
'private_key_saved' => null,
'certificate_path' => null,
'private_key_path' => null,
'valid_cert' => null,
'valid_chain' => null,
'subject' => null,
'issuer' => null,
'not_before' => null,
'not_after' => null,
'dns_names' => null,
'valid_key' => null,
'key_type' => null,
'warning_validation' => null,
'valid_pair' => null    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'enabled' => 'enabled',
'server_name' => 'server_name',
'force_https' => 'force_https',
'port_https' => 'port_https',
'port_dns_over_tls' => 'port_dns_over_tls',
'port_dns_over_quic' => 'port_dns_over_quic',
'certificate_chain' => 'certificate_chain',
'private_key' => 'private_key',
'private_key_saved' => 'private_key_saved',
'certificate_path' => 'certificate_path',
'private_key_path' => 'private_key_path',
'valid_cert' => 'valid_cert',
'valid_chain' => 'valid_chain',
'subject' => 'subject',
'issuer' => 'issuer',
'not_before' => 'not_before',
'not_after' => 'not_after',
'dns_names' => 'dns_names',
'valid_key' => 'valid_key',
'key_type' => 'key_type',
'warning_validation' => 'warning_validation',
'valid_pair' => 'valid_pair'    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'enabled' => 'setEnabled',
'server_name' => 'setServerName',
'force_https' => 'setForceHttps',
'port_https' => 'setPortHttps',
'port_dns_over_tls' => 'setPortDnsOverTls',
'port_dns_over_quic' => 'setPortDnsOverQuic',
'certificate_chain' => 'setCertificateChain',
'private_key' => 'setPrivateKey',
'private_key_saved' => 'setPrivateKeySaved',
'certificate_path' => 'setCertificatePath',
'private_key_path' => 'setPrivateKeyPath',
'valid_cert' => 'setValidCert',
'valid_chain' => 'setValidChain',
'subject' => 'setSubject',
'issuer' => 'setIssuer',
'not_before' => 'setNotBefore',
'not_after' => 'setNotAfter',
'dns_names' => 'setDnsNames',
'valid_key' => 'setValidKey',
'key_type' => 'setKeyType',
'warning_validation' => 'setWarningValidation',
'valid_pair' => 'setValidPair'    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'enabled' => 'getEnabled',
'server_name' => 'getServerName',
'force_https' => 'getForceHttps',
'port_https' => 'getPortHttps',
'port_dns_over_tls' => 'getPortDnsOverTls',
'port_dns_over_quic' => 'getPortDnsOverQuic',
'certificate_chain' => 'getCertificateChain',
'private_key' => 'getPrivateKey',
'private_key_saved' => 'getPrivateKeySaved',
'certificate_path' => 'getCertificatePath',
'private_key_path' => 'getPrivateKeyPath',
'valid_cert' => 'getValidCert',
'valid_chain' => 'getValidChain',
'subject' => 'getSubject',
'issuer' => 'getIssuer',
'not_before' => 'getNotBefore',
'not_after' => 'getNotAfter',
'dns_names' => 'getDnsNames',
'valid_key' => 'getValidKey',
'key_type' => 'getKeyType',
'warning_validation' => 'getWarningValidation',
'valid_pair' => 'getValidPair'    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const KEY_TYPE_RSA = 'RSA';
const KEY_TYPE_ECDSA = 'ECDSA';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getKeyTypeAllowableValues()
    {
        return [
            self::KEY_TYPE_RSA,
self::KEY_TYPE_ECDSA,        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['enabled'] = isset($data['enabled']) ? $data['enabled'] : null;
        $this->container['server_name'] = isset($data['server_name']) ? $data['server_name'] : null;
        $this->container['force_https'] = isset($data['force_https']) ? $data['force_https'] : null;
        $this->container['port_https'] = isset($data['port_https']) ? $data['port_https'] : null;
        $this->container['port_dns_over_tls'] = isset($data['port_dns_over_tls']) ? $data['port_dns_over_tls'] : null;
        $this->container['port_dns_over_quic'] = isset($data['port_dns_over_quic']) ? $data['port_dns_over_quic'] : null;
        $this->container['certificate_chain'] = isset($data['certificate_chain']) ? $data['certificate_chain'] : null;
        $this->container['private_key'] = isset($data['private_key']) ? $data['private_key'] : null;
        $this->container['private_key_saved'] = isset($data['private_key_saved']) ? $data['private_key_saved'] : null;
        $this->container['certificate_path'] = isset($data['certificate_path']) ? $data['certificate_path'] : null;
        $this->container['private_key_path'] = isset($data['private_key_path']) ? $data['private_key_path'] : null;
        $this->container['valid_cert'] = isset($data['valid_cert']) ? $data['valid_cert'] : null;
        $this->container['valid_chain'] = isset($data['valid_chain']) ? $data['valid_chain'] : null;
        $this->container['subject'] = isset($data['subject']) ? $data['subject'] : null;
        $this->container['issuer'] = isset($data['issuer']) ? $data['issuer'] : null;
        $this->container['not_before'] = isset($data['not_before']) ? $data['not_before'] : null;
        $this->container['not_after'] = isset($data['not_after']) ? $data['not_after'] : null;
        $this->container['dns_names'] = isset($data['dns_names']) ? $data['dns_names'] : null;
        $this->container['valid_key'] = isset($data['valid_key']) ? $data['valid_key'] : null;
        $this->container['key_type'] = isset($data['key_type']) ? $data['key_type'] : null;
        $this->container['warning_validation'] = isset($data['warning_validation']) ? $data['warning_validation'] : null;
        $this->container['valid_pair'] = isset($data['valid_pair']) ? $data['valid_pair'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getKeyTypeAllowableValues();
        if (!is_null($this->container['key_type']) && !in_array($this->container['key_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'key_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets enabled
     *
     * @return bool
     */
    public function getEnabled()
    {
        return $this->container['enabled'];
    }

    /**
     * Sets enabled
     *
     * @param bool $enabled enabled is the encryption (DoT/DoH/HTTPS) status
     *
     * @return $this
     */
    public function setEnabled($enabled)
    {
        $this->container['enabled'] = $enabled;

        return $this;
    }

    /**
     * Gets server_name
     *
     * @return string
     */
    public function getServerName()
    {
        return $this->container['server_name'];
    }

    /**
     * Sets server_name
     *
     * @param string $server_name server_name is the hostname of your HTTPS/TLS server
     *
     * @return $this
     */
    public function setServerName($server_name)
    {
        $this->container['server_name'] = $server_name;

        return $this;
    }

    /**
     * Gets force_https
     *
     * @return bool
     */
    public function getForceHttps()
    {
        return $this->container['force_https'];
    }

    /**
     * Sets force_https
     *
     * @param bool $force_https if true, forces HTTP->HTTPS redirect
     *
     * @return $this
     */
    public function setForceHttps($force_https)
    {
        $this->container['force_https'] = $force_https;

        return $this;
    }

    /**
     * Gets port_https
     *
     * @return int
     */
    public function getPortHttps()
    {
        return $this->container['port_https'];
    }

    /**
     * Sets port_https
     *
     * @param int $port_https HTTPS port. If 0, HTTPS will be disabled.
     *
     * @return $this
     */
    public function setPortHttps($port_https)
    {
        $this->container['port_https'] = $port_https;

        return $this;
    }

    /**
     * Gets port_dns_over_tls
     *
     * @return int
     */
    public function getPortDnsOverTls()
    {
        return $this->container['port_dns_over_tls'];
    }

    /**
     * Sets port_dns_over_tls
     *
     * @param int $port_dns_over_tls DNS-over-TLS port. If 0, DoT will be disabled.
     *
     * @return $this
     */
    public function setPortDnsOverTls($port_dns_over_tls)
    {
        $this->container['port_dns_over_tls'] = $port_dns_over_tls;

        return $this;
    }

    /**
     * Gets port_dns_over_quic
     *
     * @return int
     */
    public function getPortDnsOverQuic()
    {
        return $this->container['port_dns_over_quic'];
    }

    /**
     * Sets port_dns_over_quic
     *
     * @param int $port_dns_over_quic DNS-over-QUIC port. If 0, DoQ will be disabled.
     *
     * @return $this
     */
    public function setPortDnsOverQuic($port_dns_over_quic)
    {
        $this->container['port_dns_over_quic'] = $port_dns_over_quic;

        return $this;
    }

    /**
     * Gets certificate_chain
     *
     * @return string
     */
    public function getCertificateChain()
    {
        return $this->container['certificate_chain'];
    }

    /**
     * Sets certificate_chain
     *
     * @param string $certificate_chain Base64 string with PEM-encoded certificates chain
     *
     * @return $this
     */
    public function setCertificateChain($certificate_chain)
    {
        $this->container['certificate_chain'] = $certificate_chain;

        return $this;
    }

    /**
     * Gets private_key
     *
     * @return string
     */
    public function getPrivateKey()
    {
        return $this->container['private_key'];
    }

    /**
     * Sets private_key
     *
     * @param string $private_key Base64 string with PEM-encoded private key
     *
     * @return $this
     */
    public function setPrivateKey($private_key)
    {
        $this->container['private_key'] = $private_key;

        return $this;
    }

    /**
     * Gets private_key_saved
     *
     * @return bool
     */
    public function getPrivateKeySaved()
    {
        return $this->container['private_key_saved'];
    }

    /**
     * Sets private_key_saved
     *
     * @param bool $private_key_saved Set to true if the user has previously saved a private key as a string.  This is used so that the server and the client don't have to send the private key between each other every time, which might lead to security issues.
     *
     * @return $this
     */
    public function setPrivateKeySaved($private_key_saved)
    {
        $this->container['private_key_saved'] = $private_key_saved;

        return $this;
    }

    /**
     * Gets certificate_path
     *
     * @return string
     */
    public function getCertificatePath()
    {
        return $this->container['certificate_path'];
    }

    /**
     * Sets certificate_path
     *
     * @param string $certificate_path Path to certificate file
     *
     * @return $this
     */
    public function setCertificatePath($certificate_path)
    {
        $this->container['certificate_path'] = $certificate_path;

        return $this;
    }

    /**
     * Gets private_key_path
     *
     * @return string
     */
    public function getPrivateKeyPath()
    {
        return $this->container['private_key_path'];
    }

    /**
     * Sets private_key_path
     *
     * @param string $private_key_path Path to private key file
     *
     * @return $this
     */
    public function setPrivateKeyPath($private_key_path)
    {
        $this->container['private_key_path'] = $private_key_path;

        return $this;
    }

    /**
     * Gets valid_cert
     *
     * @return bool
     */
    public function getValidCert()
    {
        return $this->container['valid_cert'];
    }

    /**
     * Sets valid_cert
     *
     * @param bool $valid_cert Set to true if the specified certificates chain is a valid chain of X509 certificates.
     *
     * @return $this
     */
    public function setValidCert($valid_cert)
    {
        $this->container['valid_cert'] = $valid_cert;

        return $this;
    }

    /**
     * Gets valid_chain
     *
     * @return bool
     */
    public function getValidChain()
    {
        return $this->container['valid_chain'];
    }

    /**
     * Sets valid_chain
     *
     * @param bool $valid_chain Set to true if the specified certificates chain is verified and issued by a known CA.
     *
     * @return $this
     */
    public function setValidChain($valid_chain)
    {
        $this->container['valid_chain'] = $valid_chain;

        return $this;
    }

    /**
     * Gets subject
     *
     * @return string
     */
    public function getSubject()
    {
        return $this->container['subject'];
    }

    /**
     * Sets subject
     *
     * @param string $subject The subject of the first certificate in the chain.
     *
     * @return $this
     */
    public function setSubject($subject)
    {
        $this->container['subject'] = $subject;

        return $this;
    }

    /**
     * Gets issuer
     *
     * @return string
     */
    public function getIssuer()
    {
        return $this->container['issuer'];
    }

    /**
     * Sets issuer
     *
     * @param string $issuer The issuer of the first certificate in the chain.
     *
     * @return $this
     */
    public function setIssuer($issuer)
    {
        $this->container['issuer'] = $issuer;

        return $this;
    }

    /**
     * Gets not_before
     *
     * @return string
     */
    public function getNotBefore()
    {
        return $this->container['not_before'];
    }

    /**
     * Sets not_before
     *
     * @param string $not_before The NotBefore field of the first certificate in the chain.
     *
     * @return $this
     */
    public function setNotBefore($not_before)
    {
        $this->container['not_before'] = $not_before;

        return $this;
    }

    /**
     * Gets not_after
     *
     * @return string
     */
    public function getNotAfter()
    {
        return $this->container['not_after'];
    }

    /**
     * Sets not_after
     *
     * @param string $not_after The NotAfter field of the first certificate in the chain.
     *
     * @return $this
     */
    public function setNotAfter($not_after)
    {
        $this->container['not_after'] = $not_after;

        return $this;
    }

    /**
     * Gets dns_names
     *
     * @return string[]
     */
    public function getDnsNames()
    {
        return $this->container['dns_names'];
    }

    /**
     * Sets dns_names
     *
     * @param string[] $dns_names The value of SubjectAltNames field of the first certificate in the chain.
     *
     * @return $this
     */
    public function setDnsNames($dns_names)
    {
        $this->container['dns_names'] = $dns_names;

        return $this;
    }

    /**
     * Gets valid_key
     *
     * @return bool
     */
    public function getValidKey()
    {
        return $this->container['valid_key'];
    }

    /**
     * Sets valid_key
     *
     * @param bool $valid_key Set to true if the key is a valid private key.
     *
     * @return $this
     */
    public function setValidKey($valid_key)
    {
        $this->container['valid_key'] = $valid_key;

        return $this;
    }

    /**
     * Gets key_type
     *
     * @return string
     */
    public function getKeyType()
    {
        return $this->container['key_type'];
    }

    /**
     * Sets key_type
     *
     * @param string $key_type Key type.
     *
     * @return $this
     */
    public function setKeyType($key_type)
    {
        $allowedValues = $this->getKeyTypeAllowableValues();
        if (!is_null($key_type) && !in_array($key_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'key_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['key_type'] = $key_type;

        return $this;
    }

    /**
     * Gets warning_validation
     *
     * @return string
     */
    public function getWarningValidation()
    {
        return $this->container['warning_validation'];
    }

    /**
     * Sets warning_validation
     *
     * @param string $warning_validation A validation warning message with the issue description.
     *
     * @return $this
     */
    public function setWarningValidation($warning_validation)
    {
        $this->container['warning_validation'] = $warning_validation;

        return $this;
    }

    /**
     * Gets valid_pair
     *
     * @return bool
     */
    public function getValidPair()
    {
        return $this->container['valid_pair'];
    }

    /**
     * Sets valid_pair
     *
     * @param bool $valid_pair Set to true if both certificate and private key are correct.
     *
     * @return $this
     */
    public function setValidPair($valid_pair)
    {
        $this->container['valid_pair'] = $valid_pair;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
